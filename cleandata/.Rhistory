opposing <- t$opposing_team
date <- t$DATE
s <- t$season
matchups <- filter(game_scores, selected_team %in% c(selected, opposing) & opposing_team %in% c(selected, opposing)) %>%
filter(season==s & DATE<date) %>%
select(-game_id)
if (nrow(matchups)==0){
df <- data.frame(0, 0, as.character(games[i]))
names(df) <- c("selected_team_matchup_wins", "opposing_team_matchup_wins", "game_id")
} else{
df <- mutate(matchups,
w1=ifelse(selected_team==selected, selected_team_win, 1-selected_team_win),
w2=1-w1) %>%
summarise(selected_team_matchup_wins=sum(w1), opposing_team_matchup_wins=sum(w2)) %>%
mutate(t=selected_team_matchup_wins+opposing_team_matchup_wins,
selected_team_matchup_wins=selected_team_matchup_wins/t,
opposing_team_matchup_wins=opposing_team_matchup_wins/t,
game_id=as.character(games[i])) %>%
select(-t)
}
return(df)
}
prev_matchups <- data.frame(rbindlist(loop_result), stringsAsFactors=FALSE) %>% replace(is.na(.), 0)
prev_matchups$game_id <- as.character(prev_matchups$game_id)
## Create the fill box score file
final <- inner_join(f, select(team_win, -DATE, -VENUE_R_H, -r, -playoffs, -OPP_TEAM, -future_game, -season), by=c("game_id", "OWN_TEAM")) %>%
inner_join(select(game_scores, -DATE, -playoffs, -season), by="game_id") %>%
inner_join(rest_days, by="game_id") %>%
inner_join(trailing_games, by="game_id") %>%
inner_join(prev_matchups, by="game_id") %>%
mutate(share_of_minutes=minutes/total_minutes,
share_of_playoff_minutes=ifelse(total_playoff_minutes>0, playoff_minutes/total_playoff_minutes, 0),
share_of_playoff_points=ifelse(total_playoff_points>0, playoff_points/total_playoff_points, 0),
share_of_points=points/total_points,
share_of_minutes_signed = ifelse(OWN_TEAM==selected_team, share_of_minutes, -share_of_minutes),
home_team_selected = as.numeric(home_team_name==selected_team),
selected_team_points=ifelse(home_team_selected==1, home_team_points, road_team_points),
opposing_team_points=ifelse(home_team_selected==0, home_team_points, road_team_points),
win=ifelse(future_game==1, NA, win)) %>%
dplyr::select(-VENUE_R_H, -TOT) %>% arrange(DATE, game_id) %>%
left_join(select(fivethirtyeight, carm_elo_full, carm_elo, selected_team, wins_538), by="selected_team") %>%
rename(carm_elo_full_selected_team=carm_elo_full, carm_elo_selected_team=carm_elo, wins_538_selected_team=wins_538) %>%
left_join(select(fivethirtyeight, carm_elo_full, carm_elo, opposing_team, wins_538), by="opposing_team") %>%
rename(carm_elo_full_opposing_team=carm_elo_full, carm_elo_opposing_team=carm_elo, wins_538_opposing_team=wins_538) %>%
left_join(injuries, by="PLAYER_FULL_NAME") %>%
mutate(travel_differential=if_else(is.na(travel_differential), 0, travel_differential),
opposing_team_travel=if_else(is.na(opposing_team_travel), 0, opposing_team_travel),
selected_team_travel=if_else(is.na(selected_team_travel), 0, opposing_team_travel)) %>%
ungroup()
saveRDS(final, paste0("BOX_SCORES_", Sys.Date(), ".RDA"))
saveRDS(final, "BOX_SCORES.RDA")
#rm(list=ls())
View(model_variables)
library(dplyr)
library(ggplot2)
library(readxl)
library(data.table)
library(glmnet)
library(tidyr)
library(parallel)
library(foreach)
library(doParallel)
root <- "/Users/kim.larsen/Documents/Code/NBA_RANKINGS"
source(paste0(root, "/functions/auc.R"))
source(paste0(root, "/functions/assign_clusters.R"))
source(paste0(root, "/functions/winpercentages.R"))
source(paste0(root, "/functions/predict_game.R"))
source(paste0(root, "/functions/get_surplus_variables.R"))
source(paste0(root, "/functions/reporting.R"))
source(paste0(root, "/functions/sim_playoffs.R"))
source(paste0(root, "/functions/attach_win_perc.R"))
source(paste0(root, "/functions/manipulate_and_save_output.R"))
source(paste0(root, "/functions/save_results.R"))
source(paste0(root, "/functions/get_team_offsets.R"))
source(paste0(root, "/functions/assign_clusters_and_win_rates.R"))
source(paste0(root, "/functions/combine.R"))
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
library(dplyr)
library(ggplot2)
library(readxl)
library(data.table)
library(glmnet)
library(tidyr)
library(parallel)
library(foreach)
library(doParallel)
root <- "/Users/kim.larsen/Documents/Code/NBA_RANKINGS"
source(paste0(root, "/functions/auc.R"))
source(paste0(root, "/functions/assign_clusters.R"))
source(paste0(root, "/functions/winpercentages.R"))
source(paste0(root, "/functions/predict_game.R"))
source(paste0(root, "/functions/get_surplus_variables.R"))
source(paste0(root, "/functions/reporting.R"))
source(paste0(root, "/functions/sim_playoffs.R"))
source(paste0(root, "/functions/attach_win_perc.R"))
source(paste0(root, "/functions/manipulate_and_save_output.R"))
source(paste0(root, "/functions/save_results.R"))
source(paste0(root, "/functions/get_team_offsets.R"))
source(paste0(root, "/functions/assign_clusters_and_win_rates.R"))
source(paste0(root, "/functions/combine.R"))
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
library(dplyr)
library(ggplot2)
library(readxl)
library(data.table)
library(glmnet)
library(tidyr)
library(parallel)
library(foreach)
library(doParallel)
root <- "/Users/kim.larsen/Documents/Code/NBA_RANKINGS"
source(paste0(root, "/functions/auc.R"))
source(paste0(root, "/functions/assign_clusters.R"))
source(paste0(root, "/functions/winpercentages.R"))
source(paste0(root, "/functions/predict_game.R"))
source(paste0(root, "/functions/get_surplus_variables.R"))
source(paste0(root, "/functions/reporting.R"))
source(paste0(root, "/functions/sim_playoffs.R"))
source(paste0(root, "/functions/attach_win_perc.R"))
source(paste0(root, "/functions/manipulate_and_save_output.R"))
source(paste0(root, "/functions/save_results.R"))
source(paste0(root, "/functions/get_team_offsets.R"))
source(paste0(root, "/functions/assign_clusters_and_win_rates.R"))
source(paste0(root, "/functions/combine.R"))
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
winpercentages <- function(data, s, use_weights){
df <- subset(data, season==s) %>% distinct(game_id, .keep_all=TRUE) %>%
select(selected_team, opposing_team, selected_team_win, season_day_std, wins_538_selected_team, wins_538_opposing_team)
MM <- month(max(subset(data, season==s)$DATE))
SS <- filter(data, DATE==max(DATE))[1,"season_day_std"]
if (nrow(df)>0){
all_teams <- distinct(data, OWN_TEAM)
winrates <- list()
for (k in 1:nrow(all_teams)){
t <- as.character(all_teams[k,"OWN_TEAM"])
if (use_weights==1){
df <- mutate(df, weight=ifelse(selected_team==t, log(wins_538_opposing_team), log(wins_538_selected_team)))
#print("--- Using 538 weights")
}  else{
df$weight <- 1
}
winrate <- filter(df, selected_team==t | opposing_team==t) %>%
ungroup()
winrate <-
mutate(winrate, win=ifelse(selected_team==t, selected_team_win, 1-selected_team_win),
points_scored=ifelse(selected_team==t, selected_team_points, opposing_team_points),
points_allowed=ifelse(opposing_team==t, selected_team_points, opposing_team_points))
winrate <-
summarise(winrate,
win_rate=weighted.mean(win, weight),
n=n())
winrate <-
mutate(winrate,
opposing_team=t,
selected_team=t)
winrates[[k]] <- winrate
}
winratesdf <- data.frame(rbindlist(winrates), stringsAsFactors=FALSE) %>%
mutate(month=MM,
win_rate_season=win_rate,
win_rate_season_adj=win_rate_season*as.numeric(SS),
first_game=0) %>%
select(selected_team, opposing_team, win_rate_season, first_game, win_rate_season_adj) %>%
replace(is.na(.), 0)
return(winratesdf)
} else{
t <- distinct(data, selected_team) %>%
mutate(win_rate_season=0, opposing_team=selected_team, first_game=1, win_rate_season_adj=0)
return(data.frame(t))
}
}
attach_win_perc <- function(data, w1, w2){
## the full dataframe
dd <- mutate(data, rowid=row_number())
d <- left_join(select(dd, selected_team, opposing_team, rowid), select(w1, -opposing_team), by="selected_team") %>%
rename(winrate_season_selected_team=win_rate_season,
winrate_season_selected_team_adj=win_rate_season_adj) %>%
left_join(select(w1, -first_game, -selected_team), by="opposing_team") %>%
rename(winrate_season_opposing_team=win_rate_season,
winrate_season_opposing_team_adj=win_rate_season_adj) %>%
left_join(select(w2, -first_game, -opposing_team, -point_diff_season, -point_diff_early_season, -win_rate_season_adj, -point_diff_adj), by="selected_team") %>%
rename(winrate_season_selected_team_s=win_rate_season) %>%
left_join(select(w2, -first_game, -selected_team, -point_diff_season, -point_diff_early_season, -win_rate_season_adj, -point_diff_adj), by="opposing_team") %>%
rename(winrate_season_opposing_team_s=win_rate_season) %>%
replace(is.na(.), 0) %>%
select(-selected_team, -opposing_team) %>%
ungroup()
dd <- inner_join(dd, d, by="rowid") %>% select(-rowid)
return(dd)
}
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
attach_win_perc <- function(data, w1, w2){
## the full dataframe
dd <- mutate(data, rowid=row_number())
d <- left_join(select(dd, selected_team, opposing_team, rowid), select(w1, -opposing_team), by="selected_team") %>%
rename(winrate_season_selected_team=win_rate_season,
winrate_season_selected_team_adj=win_rate_season_adj) %>%
left_join(select(w1, -first_game, -selected_team), by="opposing_team") %>%
rename(winrate_season_opposing_team=win_rate_season,
winrate_season_opposing_team_adj=win_rate_season_adj) %>%
left_join(select(w2, -first_game, -opposing_team, -win_rate_season_adj), by="selected_team") %>%
rename(winrate_season_selected_team_s=win_rate_season) %>%
left_join(select(w2, -first_game, -selected_team, -win_rate_season_adj), by="opposing_team") %>%
rename(winrate_season_opposing_team_s=win_rate_season) %>%
replace(is.na(.), 0) %>%
select(-selected_team, -opposing_team) %>%
ungroup()
dd <- inner_join(dd, d, by="rowid") %>% select(-rowid)
return(dd)
}
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
library(dplyr)
library(ggplot2)
library(readxl)
library(data.table)
library(glmnet)
library(tidyr)
library(parallel)
library(foreach)
library(doParallel)
root <- "/Users/kim.larsen/Documents/Code/NBA_RANKINGS"
source(paste0(root, "/functions/auc.R"))
source(paste0(root, "/functions/assign_clusters.R"))
source(paste0(root, "/functions/winpercentages.R"))
source(paste0(root, "/functions/predict_game.R"))
source(paste0(root, "/functions/get_surplus_variables.R"))
source(paste0(root, "/functions/reporting.R"))
source(paste0(root, "/functions/sim_playoffs.R"))
source(paste0(root, "/functions/attach_win_perc.R"))
source(paste0(root, "/functions/manipulate_and_save_output.R"))
source(paste0(root, "/functions/save_results.R"))
source(paste0(root, "/functions/get_team_offsets.R"))
source(paste0(root, "/functions/assign_clusters_and_win_rates.R"))
source(paste0(root, "/functions/combine.R"))
## Read the box scores
box_scores <- readRDS(paste0(root, "/cleandata/box_scores.RDA")) %>%
filter(playoffs==0)
### Global settings
cutoff <- 8 # minutes per game. if a player plays less than this amount, he is excluded
estimation_window <- 1000 # number of days used to estimate the model
winstreak_window <- 91 # number of days used to calculate the weighted win %, for the short term effect
winstreak_window_s <- 31 # number of days used to calculate the weighted win %
playing_time_window <- 91 # number of days used to estimate average playing time
cluster_window <- 91 # number of days used for cluster assignment
alpha <- 0 # for elastic net
sims <- 0 # number of random normal draws used when playing games
save_results <- 1 # set to 1 if you want to save the results
weighted_win_rates <- 1
use_current_rosters <- 1
current_season <- max(box_scores$season)
# current_season <- 2019
adjust_intercept_by_team <- 0
buffer_days <- 10
### Create a date-index
datemap <- select(box_scores, DATE, future_game, season) %>%
ungroup() %>%
distinct(DATE, .keep_all=TRUE) %>%
arrange(DATE) %>%
mutate(DATE_INDEX=row_number()) %>%
group_by(season) %>%
mutate(season_day=row_number(),
season_day_std=ifelse(season_day>91, 0, 1-(season_day-1)/90)) %>%
ungroup()
box_scores <- inner_join(box_scores, select(datemap, DATE, DATE_INDEX, season_day, season_day_std), by="DATE")
## Get model variables
model_variables <- read.csv(paste0(root, "/modeldetails/model_variables.csv"), stringsAsFactors = FALSE)
### When to start and end the forecasts
start_date <- min(subset(box_scores, season==current_season)$DATE)
end_date <- max(subset(box_scores, season==current_season & playoffs==0)$DATE)
### Cut off the box scores
box_scores <- subset(box_scores, DATE<=end_date) %>%
ungroup() %>%
mutate(fb=ifelse(season==max(season), 1, 0))
### specify start and end points
ignore_season_prior_to <- 2016
start_index <- subset(datemap, DATE==start_date)$DATE_INDEX
end_index <- subset(datemap, DATE==end_date)$DATE_INDEX
### Assign clusters to the historical data and calculate rolling win percentages
box_scores_plus <- assign_clusters_and_win_rates(root, datemap, box_scores, weighted_win_rates, cluster_window)
View(box_scores_plus)
View(model_details)
View(model_details[[1]])
View(model_details[[10]])
View(box_scores_plus)
## Save clusters
clusters_and_players <-
select(box_scores_plus, DATE, PLAYER_FULL_NAME, Cluster, season) %>%
ungroup() %>%
filter(season==max(season)) %>%
arrange(Cluster, PLAYER_FULL_NAME, DATE)
### Number of clusters
nclus <- max(box_scores_plus$Cluster)
