print(subset(datemap, DATE_INDEX==i)$DATE)
print(subset(datemap, DATE_INDEX==j)$DATE)
### Data inside the window
inwindow <- filter(box_scores_plus, DATE_INDEX<j & DATE_INDEX>j-estimation_window)
### Estimate the model unless we have run out of historical data
if (counter==1 | i <= j){
### Get game_id level data
game_data <- distinct(inwindow, game_id, .keep_all=TRUE)
### Combine the data
x <- get_surplus_variables(inwindow, nclus)  %>%
inner_join(game_data, by="game_id")
## Estimate the model
Y <- x$selected_team_win
x <- x[,names(x) %in% unique(model_variables$Variable)]
X <- model.matrix(as.formula(Y ~ .), x)
set.seed(2015)
model <- cv.glmnet(y=Y, x=X, family="binomial", alpha=alpha, parallel=FALSE, nfolds=10)
c <- as.matrix(coef(model, s=model$lambda.1se))
p <- prob_win <- 1/(1+exp(-X%*%c[-1]))
## Save model details
details <- cbind.data.frame(sapply(row.names(c), as.character), sapply(c, as.numeric), stringsAsFactors = FALSE)
names(details) <- c("Variable", "Coeff")
details$DATE <- subset(datemap, DATE_INDEX==i)$DATE
details$AUROC <- AUC(Y, p)[[1]]
details$N <- nrow(X)
model_details[[modelupdates]] <- subset(details, Variable != "(Intercept)")
modelupdates <- modelupdates+1
## Get the latest win percentages
thisseason <- filter(inwindow, DATE==max(DATE))[1,"season"]
w <- weighted_win_rates
if (thisseason != current_season){
w <-0
cr <- 0
}
if (w==1){
print("Using weights")
} else{
print("Not using weights")
}
win_perc1 <- winpercentages(filter(inwindow, DATE_INDEX>j-winstreak_window), thisseason, w)
win_perc2 <- winpercentages(filter(inwindow, DATE_INDEX>j-winstreak_window_s), thisseason, w)
}
posterior <- 0.5
prior <- 0.5
if (i==max_real_date){
ytd_scores <- data.frame(rbindlist(scores)) %>%
filter(current_season_data_used==1 & is.na(prob_selected_team_win_d)==FALSE & is.na(selected_team_win)==FALSE)
posterior=mean(ytd_scores$prob_selected_team_win_d)
prior=mean(ytd_scores$selected_team_win)
rm(ytd_scores)
}
print(posterior)
print(prior)
### Predict game outcomes
thisday <- filter(box_scores, DATE_INDEX==i)
games <- unique(thisday$game_id)
for (d in 1:length(games)){
pred <- predict_game(c, filter(inwindow, DATE_INDEX>j-playing_time_window), win_perc1, win_perc2, games[d], sims, subset(thisday, game_id==games[d]), nclus, prior, posterior, "/Users/kimlarsen/Documents/Code/NBA_RANKINGS/rawdata/", model_variables, cr)
scores[[counter]] <- pred[[1]]
model_parts[[counter]] <- pred[[2]]
counter <- counter + 1
}
}
predict_game <- function(b, history, win_perc1, win_perc2, id, runs, tobescored, nclus, prior, posterior, dir, model_variables, use_current_rosters){
thisgame <- tobescored[1,]
date <- thisgame$DATE
thisseason <- thisgame$season
team1 <- thisgame$home_team_name
team2 <- thisgame$road_team_name
selected <- thisgame$selected_team
w <- thisgame$selected_team_win
w1 <- thisgame$selected_team_matchup_wins
w2 <- thisgame$opposing_team_matchup_wins
floating_base <- thisgame$fb
future <- thisgame$future_game
### Read the overrides
rosters <- data.frame(read.csv(paste0(dir, "current_rosters.csv"), stringsAsFactors = FALSE))
### First get the average minutes and standard deviations for each player
dist <- filter(history, (OWN_TEAM==team1 | OWN_TEAM==team2)) %>%
group_by(PLAYER_FULL_NAME) %>%
mutate(gap=DATE_INDEX-min(DATE_INDEX)+1,
weight=ifelse(season==thisseason, 1.0, 0.25)) %>%
summarise(m_share_of_minutes=weighted.mean(share_of_minutes, weight),
s_share_of_minutes=sd(share_of_minutes)) %>%
replace(is.na(.), 0)
## Apply the overrides
if (use_current_rosters==1){
history_override <- inner_join(select(history, -OWN_TEAM), rosters, by="PLAYER_FULL_NAME")
} else{
history_override <- history
}
#history_override <- left_join(history, overrides, by="PLAYER_FULL_NAME") %>%
#  mutate(OWN_TEAM=ifelse(is.na(NEW_TEAM)==FALSE & DATE>=as.Date(OVERRIDE_DATE, format="%m/%d/%Y"), NEW_TEAM, OWN_TEAM)) %>%
#  select(-NEW_TEAM, -OVERRIDE_DATE)
## Infer active rosters
if (nrow(filter(history_override, OWN_TEAM==team1 & season==thisseason))==0 | nrow(filter(history_override, OWN_TEAM==team2 & season==thisseason))==0){
d_current_season_data_available <- 0
thisseason2 <- thisseason-1
} else{
d_current_season_data_available <- 1
thisseason2 <- thisseason
}
dist_active <- filter(history_override, OWN_TEAM %in% c(team1,team2) & season==thisseason2) %>%
group_by(PLAYER_FULL_NAME) %>%
filter(DATE==max(DATE)) %>%
inner_join(dist, by="PLAYER_FULL_NAME") %>%
select(PLAYER_FULL_NAME, OWN_TEAM, m_share_of_minutes, s_share_of_minutes, Cluster, DATE_INDEX) %>%
group_by(OWN_TEAM) %>%
mutate(rank_minutes=percent_rank(m_share_of_minutes),
rank_time=percent_rank(DATE_INDEX),
likelihood_to_play=rank_minutes + rank_time) %>%
arrange(OWN_TEAM, -likelihood_to_play) %>%
mutate(player=row_number(),
game_id=id,
selected_team=selected,
opposing_team=ifelse(selected_team==team1, team2, team1),
home_team_selected=as.numeric(selected_team==team1),
selected_team_win=w,
selected_team_matchup_wins=w1,
opposing_team_matchup_wins=w2,
fb=floating_base) %>%
filter(player<14) %>%
select(-player, -DATE_INDEX) %>%
ungroup()
sim_share_of_minutes <- function(x){
x$share_of_minutes=min(max(rnorm(1, x$m_share_of_minutes, x$s_share_of_minutes), 0), 1)
return(x)
}
if (runs==0){
dist_active$share_of_minutes <- dist_active$m_share_of_minutes
x <- get_surplus_variables(dist_active, nclus) %>% select(-game_id)
d <- attach_win_perc(thisgame, win_perc1, win_perc2)
samplesdf <- data.frame(cbind(x, d, row.names=NULL), stringsAsFactors = FALSE)
} else if (runs==1){
dist_active_sim <- data.frame(rbindlist(lapply(split(dist_active, dist_active$PLAYER_FULL_NAME), sim_share_of_minutes)))
x <- get_surplus_variables(dist_active_sim, nclus)
d <- attach_win_perc(thisgame, win_perc1, win_perc2)
samplesdf <- inner_join(x, d, by="game_id")
} else{
ncore <- detectCores()-1
registerDoParallel(ncore)
loop_result <- foreach(j=1:runs) %dopar% {
dist_active_sim <- data.frame(rbindlist(lapply(split(dist_active, dist_active$PLAYER_FULL_NAME), sim_share_of_minutes)))
x <- get_surplus_variables(dist_active_sim, nclus)
d <- attach_win_perc(thisgame, win_perc1, win_perc2)
return(data.frame(inner_join(x, d, by="game_id")))
}
samplesdf <- data.frame(rbindlist(loop_result))
}
### Offset to apply prior for the intercept
offset <- log((1-prior)*posterior / (prior*(1-posterior)))
print(offset)
### Score the model
x <- samplesdf[,names(samplesdf) %in% unique(model_variables$Variable)]
f <- as.formula(~.)
X <- model.matrix(f, x)
prob_win <- 1/(1+exp(-X%*%b[-1] + offset))
d <- data.frame(cbind(X*c[-1], distinct(select(samplesdf, game_id, DATE, home_team_name, road_team_name, selected_team, opposing_team), game_id, .keep_all=TRUE)), stringsAsFactors = FALSE) %>%
select(-X.Intercept.)
d$roster <- rowSums(select(d, starts_with("share_minutes_cluster")))
d$circumstances <- rowSums(select(d, opposing_team_travel, opposing_team_rest, selected_team_rest, selected_team_travel, home_team_selected))
d$performance <- rowSums(select(d, selected_team_matchup_wins, opposing_team_matchup_wins, winrate_season_selected_team, winrate_season_selected_team_adj, winrate_season_opposing_team, winrate_season_opposing_team_adj))
samplesdf$prob_win <- prob_win
samplesdf$d_prob_selected_team_win <- ifelse(samplesdf$prob_win>.5, 1.0, 0.0)
prediction <- group_by(samplesdf, game_id, DATE, home_team_name, road_team_name, selected_team, opposing_team) %>%
summarise(prob_selected_team_win_d=mean(as.numeric(prob_win)),
prob_selected_team_win_b=mean(as.numeric(d_prob_selected_team_win))) %>%
mutate(current_season_data_used=d_current_season_data_available,
future_game=future) %>%
ungroup()
prediction$selected_team_win <- w
return(list(data.frame(prediction), d))
}
### Predict the past and the future
counter <- 1
modelupdates <- 1
index <- 1
scores <- list()
model_details <- list()
model_parts <- list()
max_real_date <- max(subset(box_scores_plus, future_game==0)$DATE_INDEX)
for (i in start_index:end_index){
### Make sure we only use real data
j <- min(max_real_date, i)
## Are current rosters used to pick teams
cr <- use_current_rosters
### Check the dates
print(subset(datemap, DATE_INDEX==i)$DATE)
print(subset(datemap, DATE_INDEX==j)$DATE)
### Data inside the window
inwindow <- filter(box_scores_plus, DATE_INDEX<j & DATE_INDEX>j-estimation_window)
### Estimate the model unless we have run out of historical data
if (counter==1 | i <= j){
### Get game_id level data
game_data <- distinct(inwindow, game_id, .keep_all=TRUE)
### Combine the data
x <- get_surplus_variables(inwindow, nclus)  %>%
inner_join(game_data, by="game_id")
## Estimate the model
Y <- x$selected_team_win
x <- x[,names(x) %in% unique(model_variables$Variable)]
X <- model.matrix(as.formula(Y ~ .), x)
set.seed(2015)
model <- cv.glmnet(y=Y, x=X, family="binomial", alpha=alpha, parallel=FALSE, nfolds=10)
c <- as.matrix(coef(model, s=model$lambda.1se))
p <- prob_win <- 1/(1+exp(-X%*%c[-1]))
## Save model details
details <- cbind.data.frame(sapply(row.names(c), as.character), sapply(c, as.numeric), stringsAsFactors = FALSE)
names(details) <- c("Variable", "Coeff")
details$DATE <- subset(datemap, DATE_INDEX==i)$DATE
details$AUROC <- AUC(Y, p)[[1]]
details$N <- nrow(X)
model_details[[modelupdates]] <- subset(details, Variable != "(Intercept)")
modelupdates <- modelupdates+1
## Get the latest win percentages
thisseason <- filter(inwindow, DATE==max(DATE))[1,"season"]
w <- weighted_win_rates
if (thisseason != current_season){
w <-0
cr <- 0
}
if (w==1){
print("Using weights")
} else{
print("Not using weights")
}
win_perc1 <- winpercentages(filter(inwindow, DATE_INDEX>j-winstreak_window), thisseason, w)
win_perc2 <- winpercentages(filter(inwindow, DATE_INDEX>j-winstreak_window_s), thisseason, w)
}
posterior <- 0.5
prior <- 0.5
if (i==max_real_date){
ytd_scores <- data.frame(rbindlist(scores)) %>%
filter(current_season_data_used==1 & is.na(prob_selected_team_win_d)==FALSE & is.na(selected_team_win)==FALSE)
posterior=mean(ytd_scores$prob_selected_team_win_d)
prior=mean(ytd_scores$selected_team_win)
rm(ytd_scores)
}
print(posterior)
print(prior)
### Predict game outcomes
thisday <- filter(box_scores, DATE_INDEX==i)
games <- unique(thisday$game_id)
for (d in 1:length(games)){
pred <- predict_game(c, filter(inwindow, DATE_INDEX>j-playing_time_window), win_perc1, win_perc2, games[d], sims, subset(thisday, game_id==games[d]), nclus, prior, posterior, "/Users/kimlarsen/Documents/Code/NBA_RANKINGS/rawdata/", model_variables, cr)
scores[[counter]] <- pred[[1]]
model_parts[[counter]] <- pred[[2]]
counter <- counter + 1
}
}
library(xlsx)
library(dplyr)
library(readxl)
library(stringi)
library(tidyr)
library(reshape2)
library(data.table)
library(dplyr)
library(ggmap)
library(parallel)
library(foreach)
library(doParallel)
library(rvest)
library(stringr)
source("/Users/kimlarsen/Documents/Code/NBA_RANKINGS/functions/distance_between.R")
cbs_injuries <- read_html("http://www.cbssports.com/nba/injuries/daily")
PLAYER_FULL_NAME <- cbs_injuries %>% html_nodes("tr.row1 td:nth-child(3), tr.row2 td:nth-child(3)") %>% html_text()
return_notes <- cbs_injuries %>% html_nodes("tr.row1 td:nth-child(6), tr.row2 td:nth-child(6)") %>% html_text()
daily_injuries <- data.frame(PLAYER_FULL_NAME,
return_notes,
stringsAsFactors = FALSE) %>%
mutate(clean_note=gsub("Expected to be out until at least ", "", return_notes))
convert_to_date <- function(data){
if (data$clean_note=="Game Time Decision"){
data$return_date <- Sys.Date() + 1
} else if (data$clean_note=="Out for the season"){
data$return_date <- as.Date("2017-10-25")
} else{
data$return_date <- as.Date(data$clean_note, format="%b %d")
}
if (data$return_date<Sys.Date()){
data$return_date <- data$return_date + 365
}
return(data)
}
daily_injuries <- data.frame(rbindlist(lapply(split(daily_injuries, daily_injuries$PLAYER_FULL_NAME), convert_to_date)), stringsAsFactors = FALSE) %>%
select(PLAYER_FULL_NAME, return_date) %>% distinct(PLAYER_FULL_NAME, .keep_all=TRUE)
### Read 538 data
ft8 <- read_html("http://projects.fivethirtyeight.com/2017-nba-predictions/") %>%
html_nodes("#standings-table") %>% html_table(fill=TRUE)
ft8df <- data.frame(rbindlist(ft8))
wins <- as.numeric(str_split_fixed(ft8df[4:nrow(ft8df),"Avg..Simulated.SeasonAvg..Simulation"], "-", 2)[,1])
losses <- as.numeric(str_split_fixed(ft8df[4:nrow(ft8df),"Avg..Simulated.SeasonAvg..Simulation"], "-", 2)[,2])
team <- gsub("[0-9, -]", "", ft8df[4:nrow(ft8df),"V5"])
elo <- ft8df[4:nrow(ft8df),"V1"]
carm_elo <- ft8df[4:nrow(ft8df),"V2"]
team[team=="ers"] <- "Philadelphia"
team[team=="Hornets"] <- "Charlotte"
team[team=="Clippers"] <- "LA Clippers"
team[team=="Cavaliers"] <- "Cleveland"
team[team=="Warriors"] <- "Golden State"
team[team=="Spurs"] <- "San Antonio"
team[team=="Raptors"] <- "Toronto"
team[team=="Jazz"] <- "Utah"
team[team=="Thunder"] <- "Oklahoma City"
team[team=="TrailBlazers"] <- "Portland"
team[team=="Rockets"] <- "Houston"
team[team=="Pelicans"] <- "New Orleans"
team[team=="Celtics"] <- "Boston"
team[team=="Timberwolves"] <- "Minnesota"
team[team=="Bulls"] <- "Chicago"
team[team=="Hawks"] <- "Atlanta"
team[team=="Pistons"] <- "Detroit"
team[team=="Nuggets"] <- "Denver"
team[team=="Mavericks"] <- "Dallas"
team[team=="Wizards"] <- "Washington"
team[team=="Lakers"] <- "LA Lakers"
team[team=="Kings"] <- "Sacramento"
team[team=="Knicks"] <- "New York"
team[team=="Grizzlies"] <- "Memphis"
team[team=="Pacers"] <- "Indiana"
team[team=="Bucks"] <- "Milwaukee"
team[team=="Magic"] <- "Orlando"
team[team=="Heat"] <- "Miami"
team[team=="Suns"] <- "Phoenix"
team[team=="Nets"] <- "Brooklyn"
fivethirtyeight <- data.frame(team, elo=as.numeric(elo), carm_elo=as.numeric(carm_elo),
wins_538=as.numeric(wins),
losses_538=as.numeric(losses), stringsAsFactors = FALSE) %>%
mutate(selected_team=as.character(team), opposing_team=as.character(team),
elo=elo, carm_elo=carm_elo,
pred_win_rate_538=wins_538/(wins_538+losses_538)) %>%
select(-team)
setwd("/Users/kimlarsen/Documents/Code/NBA_RANKINGS/rawdata/")
### Injury status
source_injuries <- read_html("http://espn.go.com/nba/injuries")
players <- source_injuries %>%
html_nodes('table tr.oddrow a, table tr.evenrow a') %>%
html_text()
statuses <- source_injuries %>%
html_nodes('table tr.oddrow td:nth-child(2), table tr.evenrow  td:nth-child(2)') %>%
html_text()
dates <- source_injuries %>%
html_nodes('table tr.oddrow td:nth-child(3), table tr.evenrow  td:nth-child(3)') %>%
html_text()
injuries <- data.frame(
PLAYER_FULL_NAME = players,
injury_status = statuses,
injury_date = dates,
stringsAsFactors = FALSE
) %>% arrange(PLAYER_FULL_NAME, desc(injury_date)) %>%
distinct(PLAYER_FULL_NAME, .keep_all=TRUE) %>%
left_join(daily_injuries, by="PLAYER_FULL_NAME") %>%
mutate(injury_scrape_date=Sys.Date())
injuries[is.na(injuries$return_date),"return_date"] <- Sys.Date()+1
## Current rosters
stats_page <- read_html("http://www.nbastuffer.com/2016-2017_NBA_Regular_Season_Player_Stats.html")
players <- stats_page %>%
html_nodes("tbody#PLAYER tr td:nth-child(2)") %>%
html_text()
teams <- stats_page %>%
html_nodes("tbody#PLAYER tr td:nth-child(3)") %>%
html_text()
rosters <- data.frame(
PLAYER_FULL_NAME = players,
NBAstuffer.Initials = teams,
stringsAsFactors = FALSE)
team_map <- data.frame(read_excel("schedule.xlsx", sheet=2)) %>%
select(City, NBAstuffer.Initials) %>% distinct(NBAstuffer.Initials, .keep_all=TRUE)
rosters <- inner_join(rosters, team_map, by="NBAstuffer.Initials") %>%
rename(OWN_TEAM=City) %>%
select(OWN_TEAM, PLAYER_FULL_NAME) %>%
arrange(OWN_TEAM, PLAYER_FULL_NAME) %>%
left_join(injuries, by="PLAYER_FULL_NAME")
## Save scraped data
write.csv(rosters, "current_rosters.csv", row.names = FALSE)
write.csv(rosters, paste0("rosters_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(fivethirtyeight, paste0("FiveThirtyEight_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(injuries, paste0("injuries_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(injuries, "injuries_current.csv", row.names = FALSE)
write.csv(fivethirtyeight, paste0("FiveThirtyEight_current.csv"), row.names = FALSE)
library(xlsx)
library(dplyr)
library(readxl)
library(stringi)
library(tidyr)
library(reshape2)
library(data.table)
library(dplyr)
library(ggmap)
library(parallel)
library(foreach)
library(doParallel)
library(rvest)
library(stringr)
source("/Users/kimlarsen/Documents/Code/NBA_RANKINGS/functions/distance_between.R")
cbs_injuries <- read_html("http://www.cbssports.com/nba/injuries/daily")
PLAYER_FULL_NAME <- cbs_injuries %>% html_nodes("tr.row1 td:nth-child(3), tr.row2 td:nth-child(3)") %>% html_text()
return_notes <- cbs_injuries %>% html_nodes("tr.row1 td:nth-child(6), tr.row2 td:nth-child(6)") %>% html_text()
daily_injuries <- data.frame(PLAYER_FULL_NAME,
return_notes,
stringsAsFactors = FALSE) %>%
mutate(clean_note=gsub("Expected to be out until at least ", "", return_notes))
convert_to_date <- function(data){
if (data$clean_note=="Game Time Decision"){
data$return_date <- Sys.Date() + 1
} else if (data$clean_note=="Out for the season"){
data$return_date <- as.Date("2017-10-25")
} else{
data$return_date <- as.Date(data$clean_note, format="%b %d")
}
if (data$return_date<Sys.Date()){
data$return_date <- data$return_date + 365
}
return(data)
}
daily_injuries <- data.frame(rbindlist(lapply(split(daily_injuries, daily_injuries$PLAYER_FULL_NAME), convert_to_date)), stringsAsFactors = FALSE) %>%
select(PLAYER_FULL_NAME, return_date) %>% distinct(PLAYER_FULL_NAME, .keep_all=TRUE)
### Read 538 data
ft8 <- read_html("http://projects.fivethirtyeight.com/2017-nba-predictions/") %>%
html_nodes("#standings-table") %>% html_table(fill=TRUE)
ft8df <- data.frame(rbindlist(ft8))
wins <- as.numeric(str_split_fixed(ft8df[4:nrow(ft8df),"Avg..Simulated.SeasonAvg..Simulation"], "-", 2)[,1])
losses <- as.numeric(str_split_fixed(ft8df[4:nrow(ft8df),"Avg..Simulated.SeasonAvg..Simulation"], "-", 2)[,2])
team <- gsub("[0-9, -]", "", ft8df[4:nrow(ft8df),"V5"])
elo <- ft8df[4:nrow(ft8df),"V1"]
carm_elo <- ft8df[4:nrow(ft8df),"V2"]
team[team=="ers"] <- "Philadelphia"
team[team=="Hornets"] <- "Charlotte"
team[team=="Clippers"] <- "LA Clippers"
team[team=="Cavaliers"] <- "Cleveland"
team[team=="Warriors"] <- "Golden State"
team[team=="Spurs"] <- "San Antonio"
team[team=="Raptors"] <- "Toronto"
team[team=="Jazz"] <- "Utah"
team[team=="Thunder"] <- "Oklahoma City"
team[team=="TrailBlazers"] <- "Portland"
team[team=="Rockets"] <- "Houston"
team[team=="Pelicans"] <- "New Orleans"
team[team=="Celtics"] <- "Boston"
team[team=="Timberwolves"] <- "Minnesota"
team[team=="Bulls"] <- "Chicago"
team[team=="Hawks"] <- "Atlanta"
team[team=="Pistons"] <- "Detroit"
team[team=="Nuggets"] <- "Denver"
team[team=="Mavericks"] <- "Dallas"
team[team=="Wizards"] <- "Washington"
team[team=="Lakers"] <- "LA Lakers"
team[team=="Kings"] <- "Sacramento"
team[team=="Knicks"] <- "New York"
team[team=="Grizzlies"] <- "Memphis"
team[team=="Pacers"] <- "Indiana"
team[team=="Bucks"] <- "Milwaukee"
team[team=="Magic"] <- "Orlando"
team[team=="Heat"] <- "Miami"
team[team=="Suns"] <- "Phoenix"
team[team=="Nets"] <- "Brooklyn"
fivethirtyeight <- data.frame(team, elo=as.numeric(elo), carm_elo=as.numeric(carm_elo),
wins_538=as.numeric(wins),
losses_538=as.numeric(losses), stringsAsFactors = FALSE) %>%
mutate(selected_team=as.character(team), opposing_team=as.character(team),
elo=elo, carm_elo=carm_elo,
pred_win_rate_538=wins_538/(wins_538+losses_538)) %>%
select(-team)
setwd("/Users/kimlarsen/Documents/Code/NBA_RANKINGS/rawdata/")
### Injury status
source_injuries <- read_html("http://espn.go.com/nba/injuries")
players <- source_injuries %>%
html_nodes('table tr.oddrow a, table tr.evenrow a') %>%
html_text()
statuses <- source_injuries %>%
html_nodes('table tr.oddrow td:nth-child(2), table tr.evenrow  td:nth-child(2)') %>%
html_text()
dates <- source_injuries %>%
html_nodes('table tr.oddrow td:nth-child(3), table tr.evenrow  td:nth-child(3)') %>%
html_text()
injuries <- data.frame(
PLAYER_FULL_NAME = players,
injury_status = statuses,
injury_date = dates,
stringsAsFactors = FALSE
) %>% arrange(PLAYER_FULL_NAME, desc(injury_date)) %>%
distinct(PLAYER_FULL_NAME, .keep_all=TRUE) %>%
left_join(daily_injuries, by="PLAYER_FULL_NAME") %>%
mutate(injury_scrape_date=Sys.Date())
injuries[is.na(injuries$return_date),"return_date"] <- Sys.Date()+1
## Current rosters
stats_page <- read_html("http://www.nbastuffer.com/2016-2017_NBA_Regular_Season_Player_Stats.html")
players <- stats_page %>%
html_nodes("tbody#PLAYER tr td:nth-child(2)") %>%
html_text()
teams <- stats_page %>%
html_nodes("tbody#PLAYER tr td:nth-child(3)") %>%
html_text()
rosters <- data.frame(
PLAYER_FULL_NAME = players,
NBAstuffer.Initials = teams,
stringsAsFactors = FALSE)
team_map <- data.frame(read_excel("schedule.xlsx", sheet=2)) %>%
select(City, NBAstuffer.Initials) %>% distinct(NBAstuffer.Initials, .keep_all=TRUE)
rosters <- inner_join(rosters, team_map, by="NBAstuffer.Initials") %>%
rename(OWN_TEAM=City) %>%
select(OWN_TEAM, PLAYER_FULL_NAME) %>%
arrange(OWN_TEAM, PLAYER_FULL_NAME) %>%
left_join(injuries, by="PLAYER_FULL_NAME")
## Save scraped data
write.csv(rosters, "current_rosters.csv", row.names = FALSE)
write.csv(rosters, paste0("rosters_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(fivethirtyeight, paste0("FiveThirtyEight_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(injuries, paste0("injuries_", Sys.Date(), ".csv"), row.names = FALSE)
write.csv(injuries, "injuries_current.csv", row.names = FALSE)
write.csv(fivethirtyeight, paste0("FiveThirtyEight_current.csv"), row.names = FALSE)
